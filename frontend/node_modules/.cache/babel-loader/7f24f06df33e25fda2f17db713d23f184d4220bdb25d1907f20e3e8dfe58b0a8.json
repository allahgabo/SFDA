{"ast":null,"code":"/**\n * Fetches a PDF through the React proxy (/api/...) as a binary blob,\n * then triggers a real browser Save dialog.\n *\n * Why not just <a download>:\n *   href=\"http://localhost:8000/...\" is cross-origin from port 3000,\n *   so browsers silently ignore the `download` attribute and open the\n *   file directly (showing a browser icon instead of saving).\n *\n * This function uses the same-origin proxy path /api/... so the browser\n *  never sees a cross-origin URL, and the blob trick guarantees a save.\n */\nexport async function downloadPDF(reportId, filename = null) {\n  const saveName = filename || `SFDA_Report_${reportId}.pdf`;\n  try {\n    const res = await fetch(`/api/reports/${reportId}/pdf/`);\n    if (!res.ok) throw new Error(`Server returned ${res.status}`);\n    const blob = await res.blob();\n    const blobUrl = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = blobUrl;\n    a.download = saveName;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    setTimeout(() => URL.revokeObjectURL(blobUrl), 10000);\n  } catch (err) {\n    console.error('PDF download error:', err);\n    alert(`Could not download PDF: ${err.message}`);\n  }\n}","map":{"version":3,"names":["downloadPDF","reportId","filename","saveName","res","fetch","ok","Error","status","blob","blobUrl","URL","createObjectURL","a","document","createElement","href","download","body","appendChild","click","removeChild","setTimeout","revokeObjectURL","err","console","error","alert","message"],"sources":["D:/New Project/milken_app/frontend/src/utils/downloadPDF.js"],"sourcesContent":["/**\n * Fetches a PDF through the React proxy (/api/...) as a binary blob,\n * then triggers a real browser Save dialog.\n *\n * Why not just <a download>:\n *   href=\"http://localhost:8000/...\" is cross-origin from port 3000,\n *   so browsers silently ignore the `download` attribute and open the\n *   file directly (showing a browser icon instead of saving).\n *\n * This function uses the same-origin proxy path /api/... so the browser\n *  never sees a cross-origin URL, and the blob trick guarantees a save.\n */\nexport async function downloadPDF(reportId, filename = null) {\n  const saveName = filename || `SFDA_Report_${reportId}.pdf`;\n  try {\n    const res = await fetch(`/api/reports/${reportId}/pdf/`);\n    if (!res.ok) throw new Error(`Server returned ${res.status}`);\n    const blob = await res.blob();\n    const blobUrl = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = blobUrl;\n    a.download = saveName;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    setTimeout(() => URL.revokeObjectURL(blobUrl), 10000);\n  } catch (err) {\n    console.error('PDF download error:', err);\n    alert(`Could not download PDF: ${err.message}`);\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeA,WAAWA,CAACC,QAAQ,EAAEC,QAAQ,GAAG,IAAI,EAAE;EAC3D,MAAMC,QAAQ,GAAGD,QAAQ,IAAI,eAAeD,QAAQ,MAAM;EAC1D,IAAI;IACF,MAAMG,GAAG,GAAG,MAAMC,KAAK,CAAC,gBAAgBJ,QAAQ,OAAO,CAAC;IACxD,IAAI,CAACG,GAAG,CAACE,EAAE,EAAE,MAAM,IAAIC,KAAK,CAAC,mBAAmBH,GAAG,CAACI,MAAM,EAAE,CAAC;IAC7D,MAAMC,IAAI,GAAG,MAAML,GAAG,CAACK,IAAI,CAAC,CAAC;IAC7B,MAAMC,OAAO,GAAGC,GAAG,CAACC,eAAe,CAACH,IAAI,CAAC;IACzC,MAAMI,CAAC,GAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;IACrCF,CAAC,CAACG,IAAI,GAAGN,OAAO;IAChBG,CAAC,CAACI,QAAQ,GAAGd,QAAQ;IACrBW,QAAQ,CAACI,IAAI,CAACC,WAAW,CAACN,CAAC,CAAC;IAC5BA,CAAC,CAACO,KAAK,CAAC,CAAC;IACTN,QAAQ,CAACI,IAAI,CAACG,WAAW,CAACR,CAAC,CAAC;IAC5BS,UAAU,CAAC,MAAMX,GAAG,CAACY,eAAe,CAACb,OAAO,CAAC,EAAE,KAAK,CAAC;EACvD,CAAC,CAAC,OAAOc,GAAG,EAAE;IACZC,OAAO,CAACC,KAAK,CAAC,qBAAqB,EAAEF,GAAG,CAAC;IACzCG,KAAK,CAAC,2BAA2BH,GAAG,CAACI,OAAO,EAAE,CAAC;EACjD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}